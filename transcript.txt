I want to thank everybody for coming
the title is talking as Clojure made simple on the brochure they left out the
, so it's not closer made simple in other words a tutorial enclosure or an
easy explanation of Clojure
it's not actually a comprehensive explanation of Clojure at all but a look
at a slice of what closures about a way of thinking about why you might want to
use it so I'm the person who made Clojure
I currently work on a database called a topic which is kind of a functional
database
that's right Clojure runs on the JVM architecture
I'm a co-founder of daytime of contact which builds stay Tomic and sponsors the
development and stewardship of Clojure but the main point I want to make about
myself to this audience was because in this talk I might seem somewhat
skeptical of job and after four into programming is that i've done an
absolute ton of that
that's what I did for two decades before I said if I still want to be a
programmer
I don't want to do it this way anymore so I know exactly how apps are built
using Java and C C++ and C sharp because that's what I used to do that doesn't
mean what I think about them is correct but that's my experience but I'm
wondering about you
how many ppl program in java hear how you're happy about that how you are
actively unhappy about that are looking for alternatives
okay great how many people have tried Clojure at all great people never heard
of Clojure and you're in the wrong room
ok
how people have tried Clojure and and are trying to get it to use it at work
but not yet a few maybe this talk will give you some some ways of talking about
Clojures value proposition that can help you how you will actively use Clojure
and somehow accidentally a job at one
ok and the rest couldn't get into brian gets the stock I shouldn't even mention
the Brian gets us to talk right now because we can have people filing or
maybe you're just tired of Brian gets talking about the mutability in which
case you're definitely in the group and I liked Bryan's a good friend and his
talks are great
so I appreciate your bringing this one so if you there are very few people have
never heard of pleasure
so I'm not gonna spend a lot of time on it only had one or the one more question
how many people have seen my talk simple made easy and people not okay if you so
i made spend two minutes describing me when I say simple Clojure is a
programming language runs in the jvm and JavaScript and pretty much a substantial
a subset of Clojure runs on JavaScript
so it's a program aligns with which you can target both that originally only
targeted to jb m and the clr its there still a port to the clr let's maintain
but does not seem see wide use released the first in 2007
it's sad you know surprising adoption especially from my perspective since
then given given its characteristics because it's a list its functional its
data oriented and it has a lot of things that make it seem not like the kind of
language that would succeed and this talk will really be about the data
orientation of Clojure so a lot of the best partners and the most productive
programs I know are writing everything in blank and swearing by it and then
just producing ridiculous ly sophisticated things in a very short
time and that programmer productivity matters so Adrian
cockcroft was an architect netflix now is the better adventures
how you will think java goes in the blank
okay so we know we know this
there's something about java that makes it not suitable for this blank
maybe going to use that apart just of course he was saying closer and this
talk is about maybe why
like how could this be true what is it that makes some Clojure different and
possibly a better fit for that blank
so the first thing I want to talk about is is that I think we have this tendency
in programming to think about ourselves just took a ton and our languages are
tools or techniques and I me me me me is what we're doing whatever we lose track
of the fact that we're all working for somebody else who's or for ourselves but
for a business or an organization is trying to accomplish something in the
world and the software is completely secondary to that task right it should
be measured always in terms of the cost benefit ratio the return on investment
right how quickly can we get a product to market and is what we're doing
profitable right if we're not doing that we're not really being good participants
are in our businesses or organizations
so what do the stakeholders what they really want two things they want
something good and they want it soon
so something good that you know we think we know it's something good we have you
know we know how to make things good right we have these techniques and some
things
things are good when the techniques are successful with them right so when are
types check on our test pass
we have something good but of course we all know that with our best efforts and
those things which are I'm not saying you're bad activities by the way but no
matter what we do there
we end up with programs that don't work we all know we have programs that I
check and test pass and they don't work and whatever they don't work from the
perspective of the stakeholder long as they don't do what the program was
supposed to do and what's supposed to do was something that was conveyed between
people or through documentation or papers of things that are not in
programming languages they have to meet operational requirements and they have
to be flexible
ok now there are some times where people just want something soon
and they don't want something good there are actually better languages enclosure
for that right just give me something fast that I am absolutely definitely
going to throw away will not grow will not expand will not will not take me
further
so these first two things are means right they're good but they're only good
in so far as to help ensure the latter three things so we break it down what is
it supposed to do again
it's a perspective thing if the stakeholders thinks it's doing what it's
supposed to do
they're fine of course they're going to have expressed concerns about software
was supposed to do it should do this when I press this button and they're
going to have unexpressed presume things like it should be secure
it shouldn't you know cause the computer to go on fire because it's so slow it
shouldn't require three new data centers
it should keep running and not stop for an hour every day
those are sort of the unstated presumptions of something being good but
it ends up that if you build large elaborate stateful programs
it's extremely difficult to ascertain whether or not they are going to do what
they're supposed to do and in fact if you build any one of those things if you
just build a very large program or a very elaborate program
or very stateful program it will be as hard to figure out if it's what if it's
going to do is supposed to do
so one of the things Clojure is oriented at is making it easier to understand
whether or not your program is going to do is supposed to do mostly by making it
substantially smaller and also by making it more functional in terms of
operational requirements is a boatload of things as a boatload of unstated
requirements of software
you know - are you can't apply it in the normal way with all my stuff with the
people who know how to run my machines and everything else and and that's one
of the targets of Clojure Clojure was meant to be hosted it's just a jar
it runs in the environment it's easy to sneak in right
it's just add this to one more jar and then we're and they were running but but
it's not a small thing right if you wanted to adopt common lisp say or
Pascal you would be asking your your ops team and your deployment team to start
manipulating something completely alien whose characteristics they don't
understand in terms of security
everything that's available from the jvm for securities available by a Clojure
and their performance of other concerns a very important thing though is that
now we can also reach the browser so I think you how many people write
applications were some part of the overall system touches a browser
yeah so right now you use two different things
I almost definitely used two different things and I think it's a strength of
Clojure that were delivering the same value proposition in both places both on
the server and the client even if they're separate deaths the value
proposition is necessary him almost more so in the browser which is one of the
most complex places ever in terms of performance
you know a lot of times you might look at a dynamic language and say oh you
know how could it be whatever but you know clothes right down there with the
fast languages on
admittedly the benchmark game which is a benchmark and a game so but it says we
can reach that on JavaScript we have a very interesting result here so o music
a Clojure script library suppose your script disclosure on JavaScript and home
is a library that actually wraps react
which is the new hotness what's the really interesting things here own raps
react and then spanks it in performance
how's that possible it ends up that that always use of persistent data structures
which we'll talk about in a minute
make it faster than react because the big part of reactor is doing a change
detection and change detection for immutable things is the identity
comparison
so it's super fast and in fact they re are protecting their whole thing to use
persistent data structures in JavaScript now to react
def came up to me at strange-looking said check my hand and said you're
saving us a ton of money because we're switching to that strategy
so the other part of the value proposition I said was flexibility right
people that that you know have a stake in software know that they're building a
system now button it tomorrow
things are going to change requirements can change the bread to do something
different
change is inevitable so can we change the program
can we make it more flexible and ends up there's a lot we can learn from bigger
system design in the small to make the subcomponents of systems more flexible
and of course this is old this is the oldest thing right
loose coupling but but we talked and talked and talked about it we continued
use techniques that through it like every single day you pull out a
technique you do something that's that makes this harder
so what makes it easier
so the my talk was done and somebody said you know I have this quote from
walmart labs guy you might want to put in your talk and it was like wow this is
great because he's telling my story right with closer we get to market
faster with better quality we avoid an insert unintended interruptions and job
apps encode in one area and
the application another Clojure shrinks our code base to about one-fifth the
size it would have have you written in java right
and these are the points of my talk right this is what I want this is a
stakeholder saying this is what we get x by choosing Clojure faster
time-to-market better quality right we avoid coupling problems that make it
difficult for us to change
we have a smaller code base so how does cause you do this
there are many many different characteristics to Clojure but I only
want to talk about sort of two today mostly 11 is and because this is one I
think that sets Clojure apart
it makes it somewhat different is that it has data orientation through and
through and the other is simplicity so when I say simplicity
I mean the opposite of complexity I do not mean ease and I mean Clojure is an
easy language that's easy
only you know you type and everything magically happens or some sort of
easiness metric complex things are intertwined and simple things are not
right there more independent their separate even if they have as many
things going on
this is simpler than this right for things like this is complex and for
things like this is simple
that's what I mean when I say simple untangled
so the thing is that you know all these languages can do everything right
we can do the same stuff and people are like why you know you I know I can do
the same stuff in c-sharp in Java and Scala and and Clojure and you know put
anybody any general purpose language you can accomplish the same things at the
end of the day right so what differentiates languages is what they
make practical and what they make idiomatic an enclosure we focus on
something making something idiomatic that I think is not and should be more
so that's this before we had all this highfalutin you know and
opinions of ourselves as programmers and computer scientists and stuff like that
programming you speak all data processing how many people actually do
data processing in their programs you can raise your hands
we all do right this is what most programs do you take some information
and somebody type some stuff so we sent you a message
you put it somewhere later you try to find it
you put it on the screen you send it to somebody else
that's what most programs do most of the time
sure there's a computational aspect of programs this quality of implementation
issues to this but there's nothing wrong with saying programs process data
because the data is information information systems and this is should
be what we're doing right where the stewards of the world's information and
the information is just data
it's not a complex thing that's not an elaborate thing
it's a simple thing until we programmers start touching it
so we have data processing processing most programs do this is very few
programs that don't write and data is ass fundamentally simple thing
data is just Raw immutable information
so that's the first point data is immutable if you make a data structure
you can start messing with that but actual data is is immutable
so if you have a representation for that's also a mutable you're capturing
its essence better than if you start fiddling around and that's what happens
languages fiddle around right they elaborate on data they add types they
add methods they make data active they make data mutable they make data movable
they turn into a you know an agent or some active thing
and at that point they're ruining it at least they're moving it away from what
it what it is and in object orientation I think this is rampant
because our fundamentals construct the object conflates two things it doesn't
give us two separate ways to talk about process for which objects are ok
approach and information for which there are terrible terrible terrible
roach right but what every time we have a problem we pull out an object we make
a new object we make a new class making doing the same situation of something
right and and this makes our programs more about themselves again and less
about the information programs are more increasingly about code and decreasing
me about data and I think that's a mistake
so close your embraces data that's like the simplest idea of enclosure is just
there's nothing wrong with data data has these great properties
let's use it in fact let's make it a really important first class in your
face kind of thing so close embrace it
first and foremost by having strong data literals which I'll show you in a minute
and their plane right plane it just means flat level unadorned no extra
stuff and code and this is an old list thing enclosure is represented as data
that's important for a lot of reasons that enables macros and a lot of
sophisticated program transformation things but also means that you don't
have different stuff right
the majority of functions enclosure just take data and by data I mean immutable
unadorned stuff and they return that same thing
giant library functions hundreds and hundreds and hundreds of data
manipulation functions ready to go
they take data they return data so if you have anything that's data you can
use all those functions on it which tends to press you towards making
everything data because then you have this giant library which you learn once
and you can apply to every problem you have
and in particular every time we encounter information enclosure systems
because it's different parts of systems right is a part of your system that
manipulates information is a part of your system that sort of plumbing right
or the machinery of your program like you know what a socket or communications
endpoint is more like a machine
then it is like information right so there's going to be active parts of your
program but whenever you
you're dealing with a partner program that's just about representing facts and
information we will always enclosure choose playing data to do that
so there there's a small set of data literals enclosure
they're relatively obvious right you can write integers in the normal way and
double the normal way and big decimals with them at the end there are ratios
and these are proper ratios that don't lose precision strings are in double
quotes and strings are java.lang.string when you write that you get a
java.lang.string and so it's just a literal for a string literals four
characters because we use data structures for programming right there's
a couple of extra things we need but if you look at java code is written all
with quotes around every every word
no no job and need something besides strings in order to be a successful
programming language
it needs symbols and it needs identifier so if you're going to properly represent
your child is data
those things have to be first class data structures or our atomic data types that
are different from strings so there are two in enclosure one or symbols and the
other keywords and their their use enclosure which I'm not going to you
know dive into is that symbols are generally used to reference something
else
so like variables and things like that they named something and keywords name
themselves they're like he knows if you want
they're very useful as keys and maps for instance
that's why they're called that there are true or false boolean literals and
there's no which is not as the same that's a job and all and those balloons
or job in there
java boolean those characters or Java characters etc etc and there's also
liberals 44 regex and then we have data structures some fundamental data
structures we have the singly linked list right it's in friends
those are all lists their list of numbers list of symbols a list that has
a symbol and then some numbers
that's okay can be heterogeneous and they grow at the front and they have
linked list kind of performance characteristics which means it's fast to
put something at the front and slow to find the 57,000 thing
linear time to find stuff in the middle then we have vectors there in square
brackets
right again they can be heterogeneous decides to be one with numbers and one
with symbols but you can intermix them they grow at the end in constant time
but they also offer fast access anywhere in the middle so there are different
from linked list them and then there are maps their key value key value key value
the comments are optional
the key is not need not be keyword so the first one uses keywords mapping two
integers and the second use integers mapping two strings but you can be
heterogeneous in both the key and the value and then we have sets which are
just Curly's preceded by a hash and you can have sex again heterogeneous of
anything and all of the stuff nests
one of the important things about this is that these maps they scale and are
efficient from the very small all the way to the very large so you can use
them as sort of pseudo objects in the small and have you know four or five
fields if you will or or our entries or you can have a giant map that has you
know millions tens of millions hundreds of millions of things in it the same
data structures use throughout that's range enclosure
we don't distinguish those two uses at all so all of the data structures i
showed you are immutable
there's no way to change them just like there's no way to change 42
there's no way to change a vector what you can do is make a new vector that's
slightly different from the vector you started with and you have both factors
and there's a technique called persistent data structures which makes
this making of a new slightly different version efficient the two versions will
have a substantial amount of structural sharing going on under the hood and
that's possible because they are immutable right they can share structure
because no one can change them and that's what makes it practical to use
immutable data structures all the way through the range from tiny things
through very very large things
it's not copy on write write these new modifications that you make still comply
with the big o expectations you have for the data structure in hand
and this is the key to practical functional programming is having this
so the idea behind Clojure or one of the ideas behind closure is just this right
I done so much object-oriented programming and like it's so much busy
work and so much extra stuff and when I finally later in my career learned list
by saw people building
very very interesting systems out of much much simpler stuff and I tried it
and guess what
you can build exactly the same systems out of much much simpler stuff and I
said well I can't repeat it but I was very unhappy basically something to the
effect of I have been wasting my time in my career doing what I've been doing
I need to do something I need to change what I'm doing because I'm wasting my
time wasting my life doing it this way because you can build programs the same
programs better programs that do the same things with substantially simple
stuff in fact you can build them out of the data structures I just showed you
Plus pure functions that take those things and return those things most of
your program you can build that way a little tiny bits of your program you'll
have state you'll have communication
you'll have the other the other aspects I like runtime polymorphism enclosure
has it i'll talk about in a second but you can build programs out of this and
you can build big programs out of it you can build databases out of it right
I've done and I've built a database out of it when I'm a Clojure I was targeting
being able to do everything that I used to do in Java and C++ side built
broadcast automation systems scheduling systems yield management systems
election projection systems and exit poll systems in although you know C++
and Java and C sharp
I didn't I believe that I could have used Clojure to build anything I ever
built right with maybe a tiny little bit of lower level code in small places but
that's the target foreclosure
I wanted to replace what I was doing I think the programs are substantially
smaller simpler and they're much more robust the object program of our project
oriented programming
I was doing to accomplish the same jobs so the idea behind Clojure is
let's make that dramatic let's make that the first cus way we do things
so the syntax of Clojure there's no more than you just saw it it is those data
structures that set of data structures and those those fundamental things are
format called Eden which stands for extensible data notation but it's just a
grownup version of s expressions which have been used in the list community for
years
basically you build programs out of data structures and i'll show you some of
that in a second
so the data structures are the code the syntax is not based around characters
it's based around data structures in the definition of what a function is is the
list whose head is a symbol called you no fun
and who's next thing on the list is a vector of arguments which are themselves
symbols etc etc but the syntax is described in terms of data structures
it's not like there is no syntax but that's that's where the interpretation
happens and everything that would be special in an ordinary programming
language declarations control structures function calls operators etc etc they're
all just represented as lists with the verb at the front
that's it that's the list way also everything is an expression and that's
typical of functional programming languages
that's about all I'm going to say about Clojure the language but I'm going to
show you a lot more about the use of these aspects of it a little bit more
later
so Eden this accessible data notation I showed you some built-in things there's
also a way to extend it to add new tags that are named space to allow you to
describe something new in terms of anything that's already known
so you can make up arbitrary stuff you can say will build a new parts or parts
characters and get this thing but you can say I have a new interpretation of a
vector of two numbers and we're going to call that a point and so on and so forth
and you can cascade these extensions and build furniture things but one of the
important things about Eden is this meant to be useful as for data and code
so you saw in the previous slide I said comments are optional
that's kind of critical imagine it being between you know for a blind in between
everything you said in Java you had a brother , who would like that
that would be awful right so that you can have stuff like that so I mean how
many people have ever used any system that tried to encode programming in like
JSON or XML
yeah how fun is that
yeah so this is a little bit of like AWS CloudFormation has some functions in
their syntax which is normally declarative so this is the nested
function call
but we can't you can't do this right can't program like this
so we got a program using data structures you have to have a data
structure format that's amenable to that
so this is a closer looks like I really expected to be able to eat to read it
but I just told you before that's a list right
Kirk you know the car up a prayer and death on right it defines a function the
name of the functions words takes an argument called text and there's
implementation and so on and so on and so forth so this is a port of a Peter
Norfolk's Python code
it's a short as the Python program right and and that's not like a contest right
it's it it's more about this everything that's in here is about the problem
like all the words you're reading and everything it's all about the problem is
no extra stuff
there's no static import blah
type this type that yeah yeah
extra control stuff it's all about the problem hundred percent about the
problem and that's what you want right so it's short it's free of ceremony but
most important is it's about the problem which means it's a lot easier to look at
now and later and see what you're trying to do what you're trying to accomplish
so once we have this format eden and we use it for code and we can obviously use
it for data you use it for everything right so let's say you want to have a
dsl to represent HTML because we know HTML on its own
it's kind of gross to generate and manipulate this XML plus some randomness
so this is one of many dsl's for representing HTML enclosure but it's
eaten this is the same stuff that the program was made out of the same reader
reads this if I if I call read which is available alucard enclosure
I get a vector that has a keyword that then a vector that has a keyword a
vector blood I get data you know exactly when you get the data structures I'm
going to get have a special thing I have a dom blah blah blah you know I get data
when I read this
that's great it means it's easy for me to process this is easy for me to write
a program that produces this so I can produce HTML without an extra-special
different thing
of course we would use this for our configuration files right
why not we can read it we can generate it we can process it we can manipulate
it everything we know all those hundreds of functions we know how to do we can
use to do this now add up the stuff in job how much have you got you have
syntax for what you use
I don't know what some parts of thingy right from that from Java Sea or
something to manipulate you have annotations right yes json here you have
xml there right
maybe write your own dsl use antler something keeps adding up more and more
and more different things and if you read stuff with an API what do you get
some API authors idea of the Dom for this kind of thing right
what do you get when you read xml well it depends on how you read it but you
can get this
you know machine right they called you back every time it gets a new element
Wow
this is a new programming netflix has quite profitably used Clojure to build a
very succinctly ella es el for doing a dupe and big data processing it looks
exactly like Clojure it is closer to sort of embedded enclosure and the thing
is you can run this locally and then push a button and it will distribute
over your head do cluster and run it there
same thing and you can run your own Clojure functions there too and they'll
ship them and everything else so we just do this we do this every where ever we
want there's a type and solicitation system for Clojure that uses data
there's a schema language foreclosure that uses data there are many kinds of
logic dsl's that all use data as there as a representation and and this allows
you to do something that's very interesting which is to write an
embedded dsl having people written a dsl and had more and more pressure to make
it
touring complete and and you know general purpose you start with the dsl
and it did acts and why and then people I could use II could you have
conditionals could you have case could be a blur you know there was one more
stuff
so one of the cool things about doing dsl's in a language like Clojure is that
you can sort of you
coop coop all of Clojure inside your dsl it's like oh you want to risk well short
you know what you have to do is expose something you're going to you're going
to flow through the Clojure and let closure you valid so it's very powerful
you keep doing this the other big point of programs data that allows you to
write programs generating programs and that takes a few forms in the small
business you know capability enclosure and other lists called macros
they're nothing like see macros from from your paths maybe depending on how
old r or their functions of data structures to data structures but
basically it says the compiler foreclosure says if you declare
something as a macro that if I see that in the program
I will call your code I will give you the form as data that I encountered and
you give me back a different form you can do any transformation you want
she's you can build your own syntax you can build
constructs you can extend the language however you want we do not need to wait
for me or for anybody else or for the java jsr whatever you just go
so we're doing all this stuff with raw data structures and and and how do we
contrast that with objects right
this is the Ranchi part of the talk was just warning in advance so objects like
marionettes ever has the burrito analogy but I couldn't conference are not like
burritos objects are like marionettes right
they have all these methods on them right and anybody who has access to the
object
it's like they have that that control stick thing
wikipedia says that the person who has that is called the mastermind er I
couldn't find anybody else who agree with them but that's a cool name like
you can remote control the other which you can write if you have a reference to
the object you know its type you can call any of those methods whenever you
feel like it
and whatever thread you want right just have at it you can do anything you want
because you can call those things
so whoever writes the object of class have to defend against that because
what's going to happen when the real program you start passing around
references that object
well now you have more than one master minder now you have as many master
miners as you've shared references to the thing and anybody can call something
at any time and what you end up doing end up saying well maybe they're friends
and they're standing next to each other and they're like okay let's make the
fancy horse
you know dance and i'll do the front legs and new the back bags and that
happens in puppetry right but in programming
you know sometimes they just go off and like somebody's trying to make the front
of course go this way and somebody's trying to make the back of the horse go
that way and it doesn't work and so you have to have all kinds of protection and
you can you actually can't effectively do this
java and languages like it don't give you an effective way to do this
so you're suffering from this constantly as soon as you have a reference leaked
your suffering
now I know you say I use value object some level you but you know you don't
everywhere you could but you don't and it's not a dramatic and it's still hard
and you still don't even know like if somebody gives you a reference right to
an interface
can you know that it will start dancing on you
is there anything in Java that will tell you it's not going to move around that
anyway any contract anything that type some anything
no nothing so every day you have this unhappy face and then write the final
problem we have many people write a program is just a program like it sits
by itself and it reads you know standards but standard out right
compiler writers write that and they write this great languages are really
good at that
right but that's not the real world how people write programs to talk to other
programs routinely yeah we do it all the time
how people put objects on the wire
Wow has terrifying
all right but just so you so you know a long time ago we decided that was a bad
idea
so I don't know you got the memo or whatever but yea objects don't travel on
wires or you can fake it you can pretend you can make all these elaborate things
but most of most of these things have have failed and practice right you can
you can get away with it in small circumstances but it's not how things
work right we don't actually give somebody a reference to something allow
them to sort of remote control us right
so yeah this is what I was saying before if your API takes an object
especially by our reference to an interface right so you have the concrete
classes definition sort of make you feel better about it not changing
do you know if it's going to mutate right can you type system help you with
us which is really it's such an important thing for the robustness of
your program to control this
the answer is no you're getting no help at all so your default idioms leave you
completely on your own to deal with these problems and really in a position
to encourage it encourages you to create these problems just by accident and the
other thing is so let's say you know let's say arum is not allowed at your
company
how many people are not allowed to use our miter company
everybody's allowed to use are hard Wow
go - yeah that's actually not as bad but but let's say let's say you're allowed
right
and somebody says I want you to server sighs your thing how many people would
choose our my over something else like HTTP or anything else I nobody nobody
would write because and then what do you have to do you have this interface you
said I took an object I expected all these methods on the object and now i
have to talk over a yr what do you have to do
map mapping right object relational mapping object blonde that object
something map every time you want to get to and from the outside world especially
stuff you're not writing so are my eyes out
out of the question right not going to get like some web web site to like
accept your are my calls or make our my calls to you right
anytime you have to go outside of your box out of your world view your object
worldview you have to map right so you know at java programs and
object-oriented programming simple like kicking sequel saying all it requires
object-relational mapping and that's like a problem sequel
no it's a problem with objects right that's objects are not the way the world
works nothing in the world works that way people do not hand their strings out
to other people to like start yanking on them and like that's how we're going to
build this is that so we're going to have like a soccer team right
it's like everyone can have a reference to somebody else and like you know when
you call passed to me and like would build a speak spaghetti nightmare
that's not how the world works it's completely not the way the world works
it's not how physics course
so we say objects in their way to model the real world it's not at all
it's a complete programming fabrication it's not very realistic
it's not a good fit for almost anything that's in the outside world so you can
build your own world where all the stuff makes sense but it's inherently I would
call an idiosyncratic but in particular
it's not the way that systems work right systems in the large right so what our
systems
well the word system means to cause to stand
I love that idea I mean I always think of there with this leg sort of
self-assembling to try to make something that stands up this independent parts
that you connect together substantially independent parts right because you need
to cause something the stand that's like one thing that already has three three
legs or not you're not causing it to to stand up
it's the independence of the things that matters and in general we try to build
systems in a way that makes them independent right
do we want to care if another servers using the same programming language that
we are on the same runtime the same version of java runtime or the same type
system
do we want to build a system like that where we care no we don't why because
it's going to be brittle right
it's gonna be hard to make changes we have to agree with the other person
right tomorrow we're gonna have this thing and everything's gonna be
different you know three two one
you know we don't do that the internet doesn't work that way
no right
we don't we know to specific stuff we do general stuff we try to be as
independent as possible
most things that happen between systems use one of two techniques right
they use our pc with plane data out back or they use cues where you send data and
somebody shows up later and gets the data you just send you just flow data
around this is the way that systems are built big systems big successful systems
like the internet and most systems right and those systems are flexible you
measure their flexibility in terms of how much independence they support
can you independently developed these parts of the system can somebody upgrade
they are part of the system and not mess up the other person right because like
twitter is not going to tell your web browser when they change the homepage
and like to have safari you know do something special
that's not how it works however he has independent development independent time
frames then the other thing is critical to this is that if somebody else on the
other end is going to change you have to be tolerant of things being different
you can't say well here's our contract you know the 900 things out to be
exactly this way and then i'll work and then you work then if we're going to
change anything
we have to you know have lunch and
have a meeting and and and decide the stuff again you have to be tolerant and
accepting some more things we don't have to change the lock step and so these
systems are inherently dynamic and they're inherently extensible right
that's what it is I just said systems are made with dynamic types at
extensible types right
they can accept data they weren't expecting to see and it will make them
fall over and hopefully they'll do a good job of propagating it right
they're all made this way so this is the other fundamental idea of closure
we should build the insides of our systems like we build the outside of our
systems all those value propositions that accrue to systems we want them
how many people want to have a meeting every time they change the class or a
subsystem people have meetings every time I change the class
yeah you have to write this is gonna break its gonna break so we should we
should communicate using a mutable data inside our systems for the same reason
we do outside
it makes our systems more robust it makes them easier to change it makes the
independent parts separate it makes it easier to move them around right
we get loose coupling to get subsystem independence we have flexibility and
what's the mapping
well there's no real mapping right this doesn't need mapping right RPC becomes
pc right we can we can call functions we were calling functions before there was
are right then they had are we had pc before we had our pissing we can go back
to pc we can do that right we can pass data two functions and get data back
we used to be able to do it then we had all this elaborate stuff
now I forgot how to do it right and we can implement cues and flow inside our
insider programs using cues or channels or things like that
that's the other key idea
now there's going to be processed and state right Clojure is not a closer as a
practical language of course you cannot process and state or there's no reason
to run your program
I just make the computer hot and you go home right
you're going to have state and effects but this is another area where we left
just totally with nothing
inch in object-oriented languages like Java you have nothing here like there
are very fancy functional languages that have purity will though
well they will force you through the type system to identify and isolate all
the parts of your program that could do I owe or have any kind of effect until I
would do if I a purity or via effect systems right
and then there's the alternative to that is nothing I must most people have is
absolutely nothing and then you could also have reified constructs at least
makes state change explicit and that's where Clojure sets because in Java and
C++ and C sharp
you have nothing just got nothing yeah some really raw constructs like new
taxes and you know a pat on the back and good luck buddy
and three Brides booked it
so so Clojure doesn't have any purity to it but it has explicit constructs for
state
these are like you can imagine them being variables that have semantics to
them so it's not just like anybody can come in a whack on this parable anytime
and said you say I'm gonna give you a function and you somehow apply that
function to that variable to move it from one state to another
but in doing so you can ensure it's free of conflict and free of races and it's
never going to become half of the thing and these variables always refer to
values
so you're always able to observe them or dereference them and get out a value
there's nothing else there's only these reference sells the point of values and
values
there's no mutable object that half of which could be whatever or you like a
date class that you could set the month or things like that right
a date is a value you have a reference to a date you can make that reference
point to another date
you can't change the date let's say that things you can change which are
references and you have values which are not
you can't change dates and where you can change 42 maybe you can change these
references but their atomic they just point to one thing
so between those you can get a whole bunch of different variants right Kaz
implements a successor ship model you say only make this new thing if it was
this thing I you know if my presumption is still valid and says the tiniest
version
shows a construct that wraps that so you don't have to rent the right the loop or
anything else
so here's my function applied to the inside of that use Kaz do the loop
forming and I know I'll get us a clear successorship there with no race and no
conflicts
there's also an STM enclosure that allows for bigger transactional kinds of
modifications to occur but the point is this construct is doing the job and the
contract is calling out here is where the mutation is in the system
here's where the state is and the thing is you have a way to get out of it all
right if I give you something that you don't know if it's going to change how
can you save its value
like if I give you a reference by an interface to some composite type
you don't know if it could mutate how can you save its value
what's the safe way to do that
you don't know the clones I work at all
sorry does not work what else
what's wrong love gets get this get that you get nothing you have to absolutely
nothing
so this is like a critical thing for making a system that works
you have absolutely nothing to do this with but you have to build up your own
convention around this
so like I think you should pick right you should either have explosive
constructs or go all the way to Haskell because everything in between is
catastrophe and then we have a enclosure we have something called core a sink
which is a channel model
it's a little bit richer than cues because you have to set up the threads
and do all the micro rights they have semantics that are based around
something called communicating sequential sequential processes but the
basic idea is that you're going to try to encourage especially when you're
trying to convey values through a system instead of saying I'll put the Acorn
behind this tree and you come by later and find it behind the tree
you say I'm gonna put the Acorn on the conveyor belt and you can take it off
the conveyor belt and there's a big difference between those two things
because if you put something on a conveyor belt and then go back to it
what do you expect
nothing is to command was moving and that's that's it
that float so you can't right kind of the logic you can write with variables
going back and reexamining a place to update it in place and you know try to
read it again
it flows and so flow is a much more robust way to build a system data flows
a much more robust way than variables so we want to emphasize flow over places so
program size matters right
smaller is better right there there's app this is one of the few areas where
we have like research right people have done research and said smaller programs
have fewer bugs
it's just that simple doesn't matter what programming language of this
smaller programs are fewer bugs right bigger programs have more bugs longer
time to market they're harder to maintain and they're more brittle
right but what I think is interesting is that there's two flavors of small write
a lot of languages focus on concision rights which is size in the small like
how small is your if statement you know how small is a function call how you
know tiny are your constructs how much overhead how much syntactic stuff is
there and there's a lot of languages that focus on the Ruby and Python and a
lot of languages are actually very good at concision but the the bigger impact
on a program over all right it's not moving from you know forty two
characters - 20 characters I don't get you to access right
the biggest thing is moving from more specificity which below to your program
to more generality which shrinks it
that's the big payoff that's the kind of that's the area where you're going to
get a payoff much higher than 2x so one of the other things I think we suffer
from in object orientation is death by specificity right all the time we have a
new thing we have a new idea a new piece of data boom we have a new class
get this get that get whatever I don't care if the value types whatever right
it's just a glorified map except you can't even use it as a map in Java right
so generic way to manipulate something that says get this get that get that a
new type new language gets own little vocabulary
I'm so
you're going to have more code you can have much less for use
you have more coupling right because essentially what's happening is every
object has its own little language my class
my interface my own language this is the my biggest pet peeve I want to get away
from this when we start writing get this get that it's like this is there is no
purpose to this is just life sucking so let's look at life sucking in there in
this is this is just a tiny part actually skipped this is just the
servlet request and they have a little bit of httpservletrequest which really
double the size of this thing
but my question to you is how many naps
do you see here we're like given name you get a value
I got one I got one I can actually can't do the auctioneer thing
how many you got
yeah alright so first of all this game is hard right there
there's some I got I got three inside and the overall thing is a nap too
so I got four right off by you know picking it apart
what's really interesting is look at these map interfaces they're all ad hoc
guess what else
they're all different one has setting one you can actually get the map when
you can get a list some you can get out with types this for different maps in
this one class
this is crazy right enclosure we just use maps right
this stuff came over wire in HTTP as text
how did we turn it into this what happened what happened why you know this
is crazy
now focus and I told you the curly braces are maps who can see how are you
master want to you know you see all the maps they're like this because they're
still maps right
if you're going to write code that manipulates that other stuff every
single line of code you're right it's going to be special has to you know use
whatever javafx servlet blah right and you're right code explicitly to this
thing if there's another way to do HTTP not that there is service will probably
the only way to http
but if there was another way to http will you be able to reuse that code
no it's all right it's all hardwired to this person or persons idea of like one
HTTP request is right
so yeah okay there's a tiny little benefit right . works in your ID
whoo oh my goodness because I could never remember that
so I bet something better happen when I press . because
I'm doomed otherwise of course I could look at a spec Neal like we could agree
on these names and I just don't get it
you know you can tell a kid not to put a spoon in a blender in turn on and like
they will remember that for their entire lives
they will never make that mistake but grown-up adult programmers like we need
we need protection right for front from the stuff but the protection we get is
really minimal
what's the cost it's huge right that's a idiot in inconsistent interface
it's incredibly idiosyncratic the interface is huge so if you want to like
have a second implementation
you'll get to work I does a ton more codes to consume it
you can't use any of the library already have right with the Clojure version all
the map code last of those hundreds of functions they work on this
you can create this with them you can read this with them you can merge two of
these with that and it's like you have no new code to manipulate this no new
code all the functions you already know manipulate HTTP request as soon as your
representatives data which they were by the way before we map them right
the testing right it's easier to test data can you make a program that makes
this
yeah can you make a part that makes one of these
yeah okay
and they said the other problem is your typical job of program has two to three
orders of magnitude more of that more of this right hundred classes to couple
hundred people and programs with more than a thousand classes
yeah
that's a party alright so close your partners are smaller both ways
they're more concise and they support generic programming because we just
programmed with these data abstractions we represent information is playing data
so I mean this is always the biggest reservation I love my types I like my .
I like my IDE
you know I can't I can't deal with something other than that and it's true
right
if you have the types of java right not fancier types fancy attire systems can
do more but if you have the types of java you can you can catch you know
typos and pressing and so we're supposed to pass strings but it's really likely
that your tests or your rebel interaction is going to catch that stuff
that is not a quality metric that is not sufficient for quality part of quality
right no typos
but it's not sufficient for quality right the quality is in all this other
stuff you have no where did we say we have no way to deal with state
management were encouraged to write highly couple programs were in flexible
we're not meeting the customer stakeholder quality metric at all in
fact were pointed against it time and time again or pointed at the wrong thing
and because the code is so huge we can't even really understand what it does
anymore so the biggest source of bugs and programs which is misconceptions
right everybody gets it wrong
I talked to the stakeholder they told me this I didn't think of one of the
situations when I wrote the program that's the actors of the real bugs and
programs by everything else so superficial books those are the real
bugs they're harder to see
so I think this default idioms are a big one
I'm like to spend much time on this but it was interesting to me because i
always like to look up words what this economic mean and actually means
relating to household management right so the idea of home economics is kind of
redundant
that's what the word means and I would say that you know sort of our
programming house is just like a it's like a hoarders delight everything
there's too much stuff in it
everything is too big we need too many people to do basic things
there's a lot more Clojure this was not a tutorial enclosure but the important
thing is that most of it is in libraries Clojure grows by libraries the core is
really pretty vigorously protected against growth
it's not like a you know an experiment and language design
so the one of the part of Clojure I'd like to talk about is polymorphism and
it just because it's another example of simple I haven't talked a lot about
simple but one of the cool things about closures that polymorphism is
independent
in other words it doesn't require inheritance you can imagine closer to
something called protocols there are set of functions that work together
there are polymorphic on the first argument
so it's like the same kind of single dispatch you have in java so you can
imagine them as interfaces but they don't require inheritance and the
beautiful thing about not requiring inheritance is you can have a protocol
and you can extend it to something that's finished
you know something that son wrote a long time ago and it's never going to change
and certainly is now we're going to implement your interface right
you can also take stuff from to vendors right now because what we usually have
we have the framework problem is a privilege framework in Java the one that
comes with it and people implement those interfaces but if you have a piece of
software from vendor a that has an interface and stuff from vendor be like
objects from vendor be that you want to use
how do you get better be to implement vendor a's interfaces
it just doesn't happen this is even worse than the c++ world but in Java we
still have this problem is a privilege framework that people invent the
interfaces and otherwise implement it interfaces are parochial are small so we
have polymorphism enclosures is ala carte and that reduces couple of
coupling because you don't need to derive all right I know Mabel maybe
closer seems more interesting now so it's not just about technology right
it's not even about these programming things also about eco some things like
that and the first thing that's great about using Clojure is that you get to
keep connections to the ecosystem you already know not only the runtime and
the deployment environment but those libraries right the interop in both
cases is extremely good
I'm all those Clojure data structures I showed you they all implement the
appropriate
java.util.map whatever they all can implement all the job interests you can
just take one of those things road in square brackets that was pretty easy
passage something expects a java.util.list that implements random
access right that works
ready to go Clojure is also very stable
you know I value that in java I think it's important part of why java grew and
closer takes the same approach is not like kids on github hacking away adding
every new idea or it's not a think tank experiment and it's made for production
use and it's very stable all the programs from a long time ago still run
there are books if you want to get started there's a lot of books now
foreclosure and I spoke to her last five years ago and people never heard of
closure and now there's plenty there are tools look there's an ID that looks like
a clips with club code highlighting foreclosure and like structural nab and
oh thats IntelliJ same thing
breakpoints look at you type and it starts popping stuff up
this is good we're good and you have a rappelled down there which is even
better once you get used to that
there's a ton of tools in various areas there are lots of libraries that's a
12,000 repos on github
there are lots of users the mailing list is almost 10,000 users on it and they're
all happy nice people
I promise and they all right I think that matters if you've ever seen the old
list community they were all happy nice people but close your users are happy
and nice people
that's where closures and red months where our language is a toy blew it way
up there this
Oh functional lisp what is happening in the world
look at it there is on the tech radar adopt it's actually gone off the tech
writer like of course you should be using closed already
and and they're right right people are using closed already
a lot of people are already is enclosure banks use Clojure plenty of startups
disclosure plenty of analytics houses Clojure so people are being successful
with it so I think that's the short message for today
the idea behind Clojure is to get you to better and more flexible programs sooner
and
the way it approaches that is by being data oriented and simple and I really
appreciate your time thanks thanks

